import { Injectable, OnModuleInit } from "@nestjs/common";
import { Queue, Worker, QueueEvents, JobsOptions } from "bullmq";
import IORedis from "ioredis";
import { S3Service } from "../s3/s3.service";
import { chromium } from "playwright";
import { MetricsService } from "../metrics/metrics.service";

const REDIS_URL = process.env.REDIS_URL || "redis://localhost:6379";
const WEB_URL = process.env.WEB_URL || "http://localhost:3000";

type PdfJob =
  | { type: "audit"; reportId: string; branding?: { header?: string; footer?: string } }
  | { type: "letter"; reportId: string; bureau?: "TU" | "EX" | "EQ"; items?: any[]; branding?: { header?: string; footer?: string; logoUrl?: string } }
  | { type: "letters-batch"; reportId: string; items?: any[]; branding?: { header?: string; footer?: string; logoUrl?: string } ; bureaus?: Array<"TU"|"EX"|"EQ">; };

async function renderPdfFromUrl(url: string, header = "Rapid", footer = "Generated by Rapid") {
  const browser = await chromium.launch({ headless: true, args: ["--no-sandbox"] });
  const ctx = await browser.newContext();
  const page = await ctx.newPage();

  await page.goto(url, { waitUntil: "networkidle" });

  await page.addStyleTag({
    content: `
    @media print {
      .rapid-print-header, .rapid-print-footer { position: fixed; width: 100%; left: 0; right: 0; color: #444; font-size: 10px; }
      .rapid-print-header { top: 0; border-bottom: 1px solid #ddd; padding: 4px 8px;}
      .rapid-print-footer { bottom: 0; border-top: 1px solid #ddd; padding: 4px 8px;}
      body { margin-top: 32px; margin-bottom: 32px; }
    }`
  });
  await page.evaluate(
    ({ header, footer }) => {
      const h = document.createElement("div");
      h.className = "rapid-print-header";
      h.innerText = header;
      document.body.prepend(h);
      const f = document.createElement("div");
      f.className = "rapid-print-footer";
      f.innerText = footer + " — " + new Date().toLocaleString();
      document.body.appendChild(f);
    },
    { header, footer }
  );

  const pdfBuffer = await page.pdf({
    format: "A4",
    printBackground: true,
    margin: { top: "10mm", bottom: "10mm", left: "10mm", right: "10mm" }
  });

  await browser.close();
  return pdfBuffer;
}

@Injectable()
export class PdfWorker implements OnModuleInit {
  private queue: Queue;
  private worker!: Worker;
  private events!: QueueEvents;

  constructor(private s3: S3Service, private metrics: MetricsService) {
    const connection = new IORedis(REDIS_URL);
    this.queue = new Queue("pdf", { connection });
    this.events = new QueueEvents("pdf", { connection });
  }

  async onModuleInit() {
    const connection = new IORedis(REDIS_URL);
    this.worker = new Worker(
      "pdf",
      async (job) => {
        const data = job.data as PdfJob & { callbackUrl?: string };
        if (data.type === "audit") {
          const url = `${WEB_URL}/audit/${data.reportId}`;
          const pdf = await renderPdfFromUrl(url, data.branding?.header || "Rapid — Simple Audit", data.branding?.footer || "Audit");
          const key = `pdfs/${data.reportId}.pdf`;
          await this.s3.putObject(key, pdf, "application/pdf");
          this.metrics.incPdf("audit");
          return { key };
        }
        if (data.type === "letter") {
          const payload = {
            branding: data.branding,
            items: data.items || []
          };
          const encoded = Buffer.from(JSON.stringify(payload)).toString("base64");
          const url = `${WEB_URL}/letter/${data.reportId}${data.bureau ? `?bureau=${data.bureau}` : ""}&data=${encodeURIComponent(encoded)}`;
          const pdf = await renderPdfFromUrl(url, data.branding?.header || "Rapid — Dispute Letter", data.branding?.footer || `Dispute Letter${data.bureau ? ` — ${data.bureau}` : ""}`);
          const key = `pdfs/letter-${data.reportId}${data.bureau ? `-${data.bureau}` : ""}.pdf`;
          await this.s3.putObject(key, pdf, "application/pdf");
          this.metrics.incPdf("letter");
          return { key };
        }
        if (data.type === "letters-batch") {
          const bureaus = data.bureaus && data.bureaus.length ? data.bureaus : (["TU","EX","EQ"] as Array<"TU"|"EX"|"EQ">);
          const keys: string[] = [];
          for (const b of bureaus) {
            const payload = { branding: data.branding, items: data.items || [] };
            const encoded = Buffer.from(JSON.stringify(payload)).toString("base64");
            const url = `${WEB_URL}/letter/${data.reportId}?bureau=${b}&data=${encodeURIComponent(encoded)}`;
            const pdf = await renderPdfFromUrl(url, data.branding?.header || "Rapid — Dispute Letter", data.branding?.footer || `Dispute Letter — ${b}`);
            const key = `pdfs/letter-${data.reportId}-${b}.pdf`;
            await this.s3.putObject(key, pdf, "application/pdf");
            this.metrics.incPdf("letter");
            keys.push(key);
          }
          return { keys };
        }
        return {};
      },
      { connection }
    );

    this.events.on("failed", ({ jobId, failedReason }) => {
      // eslint-disable-next-line no-console
      console.error("PDF job failed", jobId, failedReason);
    });

    this.events.on("completed", async ({ jobId }) => {
      // would fetch job result and POST to callback if provided in job data
      try {
        const job = await this.queue.getJob(jobId);
        const data = job?.data as any;
        const result = await job?.getState().then(async (state) => ({ state, result: await job?.returnvalue }));
        if (data?.callbackUrl && result) {
          await fetch(data.callbackUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ jobId, ...result })
          });
        }
      } catch (e) {
        // eslint-disable-next-line no-console
        console.error("Callback failed", e);
      }
    });
  }

  async enqueue(data: PdfJob & { callbackUrl?: string }, opts?: JobsOptions) {
    const job = await this.queue.add("generate", data, opts);
    return job.id;
  }

  async getStatus(id: string) {
    const job = await this.queue.getJob(id);
    if (!job) return { state: "not_found" };
    const state = await job.getState();
    const result = state === "completed" ? await job.returnvalue : undefined;
    return { state, result };
  }
}