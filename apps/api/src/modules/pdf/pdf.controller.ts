import { Body, Controller, Get, Param, Post, Query, UseGuards } from "@nestjs/common";
import { PrismaService } from "../prisma/prisma.service";
import { S3Service } from "../s3/s3.service";
import { chromium } from "playwright";
import { MetricsService } from "../metrics/metrics.service";
import JSZip from "jszip";
import { PdfWorker } from "./pdf.worker";
import { ApiKeyGuard } from "../auth/api-key.guard";

const WEB_URL = process.env.WEB_URL || "http://localhost:3000";

async function renderPdfFromUrl(url: string, header = "RAPID", footer = "Generated by Rapid") {
  const browser = await chromium.launch({ headless: true, args: ["--no-sandbox"] });
  const ctx = await browser.newContext();
  const page = await ctx.newPage();

  await page.goto(url, { waitUntil: "networkidle" });

  // Inject branding header/footer scaffolds; visible only in print via CSS
  await page.addStyleTag({
    content: `
    @media print {
      .rapid-print-header, .rapid-print-footer { position: fixed; width: 100%; left: 0; right: 0; color: #444; font-size: 10px; }
      .rapid-print-header { top: 0; border-bottom: 1px solid #ddd; padding: 4px 8px;}
      .rapid-print-footer { bottom: 0; border-top: 1px solid #ddd; padding: 4px 8px;}
      body { margin-top: 32px; margin-bottom: 32px; }
    }`
  });
  await page.evaluate(
    ({ header, footer }) => {
      const h = document.createElement("div");
      h.className = "rapid-print-header";
      h.innerText = header;
      document.body.prepend(h);
      const f = document.createElement("div");
      f.className = "rapid-print-footer";
      f.innerText = footer + " — " + new Date().toLocaleString();
      document.body.appendChild(f);
    },
    { header, footer }
  );

  const pdfBuffer = await page.pdf({
    format: "A4",
    printBackground: true,
    margin: { top: "10mm", bottom: "10mm", left: "10mm", right: "10mm" }
  });

  await browser.close();
  return pdfBuffer;
}

@UseGuards(ApiKeyGuard)
@Controller("pdfs")
export class PdfController {
  constructor(
    private prisma: PrismaService,
    private s3: S3Service,
    private metrics: MetricsService,
    private pdfWorker: PdfWorker
  ) {}

  @Post(":reportId")
  async generateAudit(@Param("reportId") reportId: string) {
    const report = await this.prisma.creditReport.findUnique({ where: { id: reportId } });
    if (!report) {
      throw new Error("Report not found");
    }

    const url = `${WEB_URL}/audit/${reportId}`;
    const pdfBuffer = await renderPdfFromUrl(url, "Rapid — Simple Audit", "Audit");

    const key = `pdfs/${reportId}.pdf`;
    await this.s3.putObject(key, pdfBuffer, "application/pdf");
    const downloadUrl = await this.s3.presignGet(key);
    this.metrics.incPdf("audit");
    return { ok: true, key, downloadUrl };
  }

  @Post("letter/:reportId")
  async generateLetter(@Param("reportId") reportId: string, @Query("bureau") bureau?: string) {
    const report = await this.prisma.creditReport.findUnique({ where: { id: reportId } });
    if (!report) {
      throw new Error("Report not found");
    }
    // Render a dedicated letter route (print-friendly) with optional bureau
    const url = `${WEB_URL}/letter/${reportId}${bureau ? `?bureau=${encodeURIComponent(bureau)}` : ""}`;
    const pdfBuffer = await renderPdfFromUrl(url, "Rapid — Dispute Letter", `Dispute Letter${bureau ? ` — ${bureau}` : ""}`);

    const key = `pdfs/letter-${reportId}${bureau ? `-${bureau}` : ""}.pdf`;
    await this.s3.putObject(key, pdfBuffer, "application/pdf");
    const downloadUrl = await this.s3.presignGet(key);
    this.metrics.incPdf("letter");
    return { ok: true, key, downloadUrl };
  }

  @Post("letters/batch/:reportId")
  async generateLettersBatch(@Param("reportId") reportId: string) {
    const report = await this.prisma.creditReport.findUnique({ where: { id: reportId }, include: { bureaus: true } });
    if (!report) {
      throw new Error("Report not found");
    }
    const bureaus = (report.bureaus.map((b) => b.bureau) as Array<"TU" | "EX" | "EQ">) || ["TU", "EX", "EQ"];

    const zip = new JSZip();
    const results: Array<{ bureau: string; key: string; downloadUrl: string }> = [];

    for (const b of bureaus) {
      const url = `${WEB_URL}/letter/${reportId}?bureau=${encodeURIComponent(b)}`;
      const pdf = await renderPdfFromUrl(url, "Rapid — Dispute Letter", `Dispute Letter — ${b}`);
      const key = `pdfs/letter-${reportId}-${b}.pdf`;
      await this.s3.putObject(key, pdf, "application/pdf");
      const downloadUrl = await this.s3.presignGet(key);
      results.push({ bureau: b, key, downloadUrl });
      zip.file(`letter-${reportId}-${b}.pdf`, pdf);
      this.metrics.incPdf("letter");
    }

    const zipBuffer = await zip.generateAsync({ type: "nodebuffer", compression: "DEFLATE" });
    const zipKey = `pdfs/letters-${reportId}.zip`;
    await this.s3.putObject(zipKey, zipBuffer, "application/zip");
    const zipUrl = await this.s3.presignGet(zipKey);

    return { ok: true, items: results, zipKey, zipUrl };
  }

  @Post("jobs")
  async enqueueJob(
    @Body()
    body: {
      type: "audit" | "letter" | "letters-batch";
      reportId: string;
      bureau?: "TU" | "EX" | "EQ";
      items?: any[];
      branding?: { header?: string; footer?: string; logoUrl?: string };
      callbackUrl?: string;
      bureaus?: Array<"TU" | "EX" | "EQ">;
    }
  ) {
    const id = await this.pdfWorker.enqueue(body);
    return { ok: true, jobId: id };
  }

  @Get("jobs/:id")
  async getJob(@Param("id") id: string) {
    return this.pdfWorker.getStatus(id);
  }
}